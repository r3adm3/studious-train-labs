#!meta

{"kernelInfo":{"defaultKernelName":null,"items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"html","languageName":"HTML"},{"name":"sql","languageName":"SQL"},{"name":"kql","languageName":"KQL"},{"name":"mermaid","languageName":"Mermaid"},{"name":"httpRequest","languageName":"http"},{"name":"value"}]}}

#!markdown

# Passwords

## Introduction

This notebok is intended to help you understand passwords in more detail. The interactive nature of these exercises should help you become familiar with the key issues and assist you in understanding the difference between 'bad' and 'good' passwords.

The accompanying slide deck provides a basic summary of the factors involved in password quality. But before we dig deeper, we should define what we mean when labelling a password as good, bad, poor, quality etc.

#!markdown

### What Makes a Password Good or Bad?

The whole point of a password is to protect resources by limiting access to those who are authorised. This can only be ensured if one key principle is adhered to:

* The password is a secret, it must only be known to those who are authorised

If this principle is adhered to, the resource remains safe. If not, the resource can no longer be considered secure from unauthorised use.

The key factor is that a password is secret, so anything that makes a password more likely to remain secret enhances its quality. Conversely, anything that diminishes its chances of remaining secret, will lessen its quality.

You may point out that the ongoing secrecy of a password is influenced by factors other than the password itself. If so, you are entirely correct. Issues like password storage, reuse and sharing etc. can have a huge effect on maintaining secrecy. However, these issues are covered elsewhere; this section relates solely to the passwords themselves.

A good password is, therefore, one that is secret and is likely to remain so. The next section deals with creating passwords that meet these criteria.

#!markdown

#### Entropy, Randomness and Guessability

These three terms are all measures of a password's quality, otherwise defined as the likelihood of it remaining secret.

**Randomness** is a measure of predictability. Flipping a coin has an equal chance of producing a heads or tails - a 1 or a 0 - it's therefore impossible to predict with certainty what the next flip will be. There are only two possible results from a coin flip and each is as likely as the other. A previous flip has no influence on any subsequent flip; this represents perfect randomness.
Exactly the same principle would apply with any set of characters, e.g. a-z, A-Z, 1-9 etc. the only thing that differs is that the number of possible results for each item.

**Entropy** is essentially a measure of randomness combined with the length of the password. It is usually measured in bits. A single coin flip can be a heads or a tails, the range of possibilities can therefore be defined in one bit (e.g. a 1 = heads, a 0 = tails). A single coin flip therefore has an entropy of 1 bit.

|1|2|3|4|5|6|7|8|
undefined|-|-|-|-|-|-|-|-|

#!csharp

using System.Collections;
ArrayList nums = new ArrayList();



    void p(string m)=>Console.WriteLine(m);
    for(int cntr = 1, cntrd = 0; cntr < 100; cntr++)
    {for(int k = 0; k < 2; j++, cntr++){
        p((cntr == cntrd + 2) ? "Buzz" : cntr.ToString());
    }
}
    
    string[] s = new string[100];
    
    for(int i = 0, th = 0, fi = 100; i < 100; i)
    {




    }
    
    
    
    for(int fb = 0, bz = 0, fz = 0; fz < 100;)
       p( (cntr == (cntrd+5) && (cntrd +3)) ? "FIZZBUZZ" : cntr.ToString());    
    for(int f = 0, fb = cntrd + 14; f < 2; f++)
            p((cntr % 5 == 0) ? "Buzz" : cntr.ToString());
        p((cntr % 15 == 0) ? "" : "Fizz");
     
 P =n5 

#!csharp

int jeff = 100%189;
Console.WriteLine(jeff.ToString());

#!csharp

for(int i = 1; i < 100;)
{
    for(int j = 0; j < 15; j++, i++){
        for(int k = 0; k < 2; j++, i++)
        {
            p((i % 5 == 0) ? "Buzz" : i.ToString());
        }
        p((i++ % 5 == 0) ? "FizzBuzz" : "Fizz");
    }    
}
   nums.Insert(i,((i++ % 5 == 0) ? "Buzz" : i.ToString()));
void p(string m)=>Console.WriteLine(m);

for(int f = 0; f < 100; f+=3)
{

}using System.Collections;
var charOptions = new[]{'0','1'};
var charArray = new[]{'0','0','0','0','0','0','0','0'};
ArrayList charArrayList = new ArrayList();

#!csharp

string[] s = new string[100];
        foreach (var d in (new Hashtable(){{"1","1"},{"3","fizz"},{"5","buzz"},{"15","fizzbuzz"}})){
            for(int n = 0; n < d.Display()

                var div = new Hashtable(){{"1","1"},{"3","fizz"},{"5","buzz"},{"15","fizzbuzz"}};

#!csharp

 foreach(var dic in (new Dictionary<int, string>(){{1,"1"},{3,"fizz"},{5,"buzz"},{15,"fizzbuzz"}}));
   
 foreach(var d in div){
    Console.WriteLine(d.Display());
 }

 var students = new Dictionary<int, StudentName>()
        {
            { 111, new StudentName { FirstName="Sachin", LastName="Karnik", ID=211 } },
            { 112, new StudentName { FirstName="Dina", LastName="Salimzianova", ID=317 } },
            { 113, new StudentName { FirstName="Andy", LastName="Ruth", ID=198 } }
        };

#!csharp

using System.Collections;
ArrayList l = new ArrayList(1000);
void p(string m)=>Console.WriteLine(m);

for(int n = 0; n < 100; l.Insert(n++,(n+1)));
foreach(object o in l){m(o).ToString();}
for(int f=3, b=5; f < 100; l.Insert(f-1,"Fizz"), f+=3, b+=5)
    l.Insert(b-1,((b % 15 == 0) ? "FizzBuzz" : "Buzz"));

#!csharp

using System;
using System.Collections;
var charOptions = new[]{'0','1'};
var charArray = new[]{'0','0','0','0','0','0','0','0'};
ArrayList charArrayList = new ArrayList();
var totalCombos = System.Math.Pow( charArray.Length, charOptions.Length);

for(int i = 0; i < (int)totalCombos; i++){

    

}

for(int i = 0; i < charArray.Length; i++){
    foreach(var option in charOptions){
        for(int line = 0; line < charArrayList.Count; line++){
            charArrayList.Add()
        }
    }
}
